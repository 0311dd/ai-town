import * as CONFIG from './seconfig.js' 
import * as UTIL from './eutils.js'
import { g_ctx }  from './secontext.js' // global context


function generate_preamble() {
    const preamble = '' +
        '// Map generated by se.js [' + new Date() + ']\n' +
        '\n' +
        'import { SpritesheetData } from "../../schema";' +
        '\n' +
        'export const data: SpritesheetData = {\n' +
        '  frames: {\n' +
        '\n';
       return preamble; 
}

const bgtile_string_start = '' +
    'export const bgtiles = [\n' +
    '   [\n'

function write_map_file(bg_tiles_0, bg_tiles_1, obj_tiles_1, obj_tiles_2){
    let text = generate_preamble(); 
    text += bgtile_string_start;

    for(let row = 0; row < bg_tiles_0.length; row++) {
        text += '[ ';
        for(let column = 0; column < bg_tiles_0[row].length; column++) {
            text += bg_tiles_0[row][column];
            if (column != bg_tiles_0.length - 1){
                text += ' , ';
            }
        }
        text += '],\n';
    }
    text += '],\n';
    text += '[\n';
    for(let row = 0; row < bg_tiles_1.length; row++) {
        text += '[ ';
        for(let column = 0; column < bg_tiles_1[row].length; column++) {
            text += bg_tiles_1[row][column];
            if (column != bg_tiles_1.length - 1){
                text += ' , ';
            }
        }
        text += '],\n';
    }
    text += '],];\n\n';

    text += ''+
    'export const objmap = [\n'+
    '[\n';

    for(let row = 0; row < obj_tiles_1.length; row++) {
        text += '[ ';
        for(let column = 0; column < obj_tiles_1[row].length; column++) {
            text += obj_tiles_1[row][column];
            if (column != obj_tiles_1.length - 1){
                text += ' , ';
            }
        }
        text += '],\n';
    }
    text += '],\n';
    text += '[\n';

    for(let row = 0; row < obj_tiles_2.length; row++) {
        text += '[ ';
        for(let column = 0; column < obj_tiles_2[row].length; column++) {
            text += obj_tiles_2[row][column];
            if (column != obj_tiles_2.length - 1){
                text += ' , ';
            }
        }
        text += '],\n';
    }
    text += '],];\n';

    download(text, "map.js", "text/plain");
}


// Function to download data to a file
function download(data, filename, type) {
    var file = new Blob([data], {type: type});
    if (window.navigator.msSaveOrOpenBlob) // IE10+
        window.navigator.msSaveOrOpenBlob(file, filename);
    else { // Others
        var a = document.createElement("a"),
                url = URL.createObjectURL(file);
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        setTimeout(function() {
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);  
        }, 0); 
    }
}

export function generate_sprite_file() {

    let layer0 = g_ctx.g_layers[0];
    console.log("generate_sprite_file");

    let text = generate_preamble();

    let animations = Array.from(Array(CONFIG.leveltileheight), () => new Array().fill(null)); 

    for (let row = 0; row < CONFIG.leveltileheight; row++) {
        if (!layer0.tilearray[row][0]) {
            // FIXME
            // Assume row is empty if first tile is. 
            continue;
        }



        for (let x = 0; x < layer0.tilearray[row].length; x++) {

            // tileY_X: {
            //     frame: { x: 0, y: 32, w: 32, h: 32 },
            //     sourceSize: { w: 32, h: 32 },
            //     spriteSourceSize: { x: 0, y: 0 },
            //   },

            let framename = 'tile' + row + "_" + x;

            animations[row].push(framename);
            let frame = layer0.tilearray[row][x];
            text += framename + ": { \n";
            text += '\tframe: {';
            text += 'x: '+ frame.x+ ", y: "+ frame.y+ ', w: '+ g_ctx.tiledimx+ ', h: '+ g_ctx.tiledimy+ ' },\n';
            text += '\tsourceSize: {';
            text += ' w: '+ g_ctx.tiledimx+ ', h: '+ g_ctx.tiledimy+ ' },\n';
            text += '\tspriteSourceSize: {';
            text += 'x: '+0+ ", y: "+ 0 + ' },\n';
            text += '\t},\n';
        }
    }
    text += '},\n';
    text += 'meta: {\n';
    text += '\tscale: 1,\n';
    text += '},\n';
    text += 'animations: {\n';

    for (let row = 0; row < CONFIG.leveltileheight; row++) {
        if(animations[row].length == 0) {
            continue;
        }
        text += "row"+row+" : [";
        for (let x = 0; x < animations[row].length; x++){
            text += "'"+animations[row][x];
            if (x < animations[row].length - 1){
                text += ",";
            }
        }
        text += "],\n"
    }


    text += '},\n';
    text += '};\n';

    console.log(text);
    UTIL.download(text, "animatedsprite.js", "text/plain");
    ///write_map_file(tile_array0, tile_array1, tile_array2, tile_array3); 
}